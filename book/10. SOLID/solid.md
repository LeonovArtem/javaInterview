# **SOLID**

* Single responsibility — принцип единственной ответственности
* Open-closed — принцип открытости / закрытости
* Liskov substitution — принцип подстановки Барбары Лисков
* Interface segregation — принцип разделения интерфейса
* Dependency inversion — принцип инверсии зависимостей

##  Single responsibility
Принцип единственной ответственности обозначает, что каждый объект должен иметь 
одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс.

Проектирование классов с направленностью на обеспечение единственной обязанности упрощает 
дальнейшие модификации и сопровождение, так как проще разобраться в одном блоке 
функциональности, нежели распутывать сложные взаимосвязи между различными функциональными
блоками.

Следование SRP весьма полезная практика с точки зрения повторного использования кода. 
Сложные объекты с комплексными зависимостями обычно очень сложно использовать повторно, 
особенно если нужна только часть реализованного в них функционала.

## Open-closed
Принцип открытости / закрытости декларирует, 
что программные сущности (классы, модули, функции и т. п.) должны быть открыты для 
расширения, но закрыты для изменения. Это означает, 
что эти сущности могут менять свое поведение без изменения их исходного кода.

Следование принципу OCP заключается в том, что программное обеспечение изменяется не через 
изменение существующего кода, а через добавление нового кода. 
То есть созданный изначально код остаётся «нетронутым» и стабильным, 
а новая функциональность внедряется либо через наследование реализации, 
либо через использование абстрактных интерфейсов и полиморфизм.

## Liskov substitution
Принцип подстановки Барбары Лисков заключается в том, что поведение наследуемых классов должно
быть ожидаемым для кода, который использует этот класс.

## Interface segregation
Принцип разделения интерфейса говорит о том, что клиенты не должны зависеть от методов, 
которые они не используют. Принцип разделения интерфейсов говорит о том, 
что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, 
чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе.
В итоге, при изменении метода интерфейса не должны меняться клиенты, 
которые этот метод не используют.

## Dependency inversion
Dependency inversion - завязываемся на интерфейс, а не на реализацию.


